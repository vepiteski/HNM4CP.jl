include("sprandsymG.jl")
using Dates

function  chr2015(n :: Integer;
                  dens :: Real = 1.0,   # dense problems
                  cn :: Real   = 100.0  # default condition number
                  )

    ##
    # [M,q,x,x1] = chr2015(n,dens,cn)
    #
    # Return random sparse data for the linear complementarity problem (LCP)
    #
    #    0 ≤ x _|_ (Mx+q) ≥ 0,
    #
    # in the style of the paper by Curtis, Han, and Robinson given below. On
    # return, the matrix M is positive definite.
    #
    # The seed of the random number generator is supposed to have been set
    # before calling hr2015, so that various problems can be get by calling
    # the function repetitively.
    #
    # On entry
    # ^^^^^^^^
    # - n: the number of variables,
    # - dens: required density of M
    # - cn: required condition number of M
    #
    # On return
    # ^^^^^^^^
    # - M: an nxn sparse positive definite matrix generated by
    #   'sprandsym', with density 'dens' and condition number 'cn',
    # - q: vector of LCP, such that 1/3 of the components of the solution
    #   'x' are positive, 1/3 of the components of y = M*x+q are positive at
    #   the solution 'x', and the 1/3 components of x and y both vanish,
    # - x: solution to LCP,
    # - x1: suggested initial iterate.
    #
    # Reference
    # ^^^^^^^^^
    # F.E. Curtis, Z. Han, and D.P. Robinson (2015). "A globally convergent
    # primal-dual active-set framework for large-scale convex quadratic
    # optimization", Computational Optimization and Applications 60:2,
    # 311-341. http://dx.doi.org/10.1007/s10589-014-9681-9
    #
    # Adapted from Matlab by Jean-Pierre Dussault  Nov 2024
    #
    
    M  = []
    q  = []
    x  = []
    x1 = []
    
    # Introductory message
    @printf("\nRandom LCP problem with positive definite matrix (%s)\nCurtis-Han-Robinson generation style",Dates.now())
    @printf("\n. n       = %5i\n. density =     %7.1e\n. cond    =     %7.1e",n,dens,cn)
    
    # Compute M
    
    @printf("\nGenerating the data")
    
    tic = time()
    
    eigv = rand(n)
    eig1 = minimum(eigv)
    eign = maximum(eigv)
    eigv = 1.0 .+ (eigv .- eig1) ./ (eign-eig1)*(cn-1)	# they range from 1 to cn
    M    = sprandsym(n,dens,eigv)
    
    # Set x (the solution)
    
    x = vec(sprand(n,1,1/3))
    
    # Set q
    
    AE  = findall(x .== 0.0)
    I   = findall(x .>  0.0)

    nAE = length(AE)
    nE  = Int(round(nAE/2, RoundToZero))
    
    if nE > 0
        ind = randperm(nAE)
        A = AE[ind[1:nE]]
        E = AE[ind[nE+1:end]]
    else
        A = AE
        E = []
    end
    
    q     = zeros(n)
    IE    = union(I,E)
    q[IE] = -M[IE,:]*x
    q[A]  = 1.0 .- M[A,:]*x

    # Set initial x1
    
    x1 = zeros(n)

    toc = time() - tic
    @printf(" (spent time %g sec)",toc)

    return LCPModel(M, q, x₀=x1), Array(x), A, I, E

end
